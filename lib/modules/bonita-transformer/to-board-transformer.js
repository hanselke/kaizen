// Generated by CoffeeScript 1.4.0
(function() {
  var activityDefinitionTransformer, moment, orderFromActivityDefinition, _;

  _ = require('underscore-ext');

  moment = require('moment');

  activityDefinitionTransformer = require('./activity-definition-transformer');

  orderFromActivityDefinition = function(activityDefinition) {
    var label;
    if (!(activityDefinition.label && activityDefinition.label.length > 0 && activityDefinition.label.indexOf(" ") > 0)) {
      return 9999;
    }
    label = activityDefinition.label.substr(0, activityDefinition.label.indexOf(" "));
    return parseInt(label, 0);
  };

  /*
  Transforms raw data to the one that is sent to the client.
  */


  module.exports = function(processDefinition, processInstances) {
    var activity, activityDefinition, activityDefinitionForGroup, activityDefinitionUUID, activityDefinitions, adMap, afterTime, beforeTime, card, group, i, instance, instanceStateUpdates, lane, lastUpdate, myLane, result, sortedActivityDefinitionsForState, startedDate, totalTime, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _p, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    result = {
      lanes: []
    };
    /*
      Here is what needs to happen now:
      1. We need to build the lanes
      We have 1 + n lanes, where the first one is the start lane, and the rest are, sorted by order, the isState activity definitons
    */

    activityDefinitions = _.map((_ref = processDefinition.activities) != null ? _ref.ActivityDefinition : void 0, activityDefinitionTransformer);
    adMap = {};
    result.lanes.push({
      label: "Start",
      name: "",
      order: 0,
      activityDefinitions: [],
      id: '',
      totalTime: 0,
      totalCost: 0,
      beforeTime: 0,
      afterTime: 0,
      cards: []
    });
    sortedActivityDefinitionsForState = _.sortBy(_.filter(activityDefinitions, function(x) {
      return x.isState;
    }), function(x) {
      return x.order;
    });
    console.log("SORTED: " + (JSON.stringify(sortedActivityDefinitionsForState)));
    for (_i = 0, _len = sortedActivityDefinitionsForState.length; _i < _len; _i++) {
      activityDefinition = sortedActivityDefinitionsForState[_i];
      result.lanes.push({
        label: activityDefinition.description || "",
        name: activityDefinition.name || "",
        order: activityDefinition.order,
        id: activityDefinition.id,
        totalTime: 0,
        totalCost: 0,
        beforeTime: 0,
        afterTime: 0,
        activityDefinitions: [activityDefinition],
        cards: []
      });
    }
    /*
      2. We need to assign activityDefinition's to the right lanes,starting wiht start and end.
    */

    _.first(result.lanes).activityDefinitions.push(_.find(activityDefinitions, function(x) {
      return x.isStart;
    }));
    _.last(result.lanes).activityDefinitions.push(_.find(activityDefinitions, function(x) {
      return x.isEnd;
    }));
    /*
      3. And now the fun part, we go from element 1 to n and find the matching assign+group,
      and put that in lane n - 1
    */

    for (i = _j = 1, _ref1 = result.lanes.length - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
      group = _.first(result.lanes[i].activityDefinitions).group;
      activityDefinitionForGroup = _.find(activityDefinitions, function(x) {
        return x.isAssign && x.group === group;
      });
      result.lanes[i - 1].activityDefinitions.push(activityDefinitionForGroup);
    }
    /*
      4. Now we assign it to the map
    */

    _ref2 = result.lanes;
    for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
      lane = _ref2[_k];
      _ref3 = lane.activityDefinitions;
      for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
        activityDefinition = _ref3[_l];
        adMap[activityDefinition.id] = lane;
      }
    }
    /*
      5. Now we work with process instances.
    */

    processInstances = processInstances.ProcessInstance;
    for (_m = 0, _len3 = processInstances.length; _m < _len3; _m++) {
      instance = processInstances[_m];
      _ref5 = (_ref4 = instance.activities) != null ? _ref4.ActivityInstance : void 0;
      for (_n = 0, _len4 = _ref5.length; _n < _len4; _n++) {
        activity = _ref5[_n];
        activityDefinitionUUID = (_ref6 = activity.activityDefinitionUUID) != null ? _ref6.value : void 0;
        if (activity.state !== "FINISHED") {
          myLane = adMap[activityDefinitionUUID];
          /*
                              startedDate= moment( activity.startedDate || 0) #1354080180430
                    lastUpdate = moment(activity.lastUpdate || 0)   #1354088710758
          */

          startedDate = activity.startedDate || 0;
          lastUpdate = activity.lastUpdate || 0;
          totalTime = lastUpdate - startedDate;
          beforeTime = 0;
          afterTime = 0;
          if (startedDate === 0 || lastUpdate === 0 || totalTime > 10000000000) {
            totalTime = 0;
            beforeTime = 0;
            afterTime = 0;
          }
          instanceStateUpdates = activity.instanceStateUpdates;
          if (_.isObject(instanceStateUpdates) && _.keys(instanceStateUpdates).length > 0) {
            instanceStateUpdates = [instanceStateUpdates.InstanceStateUpdate];
          }
          if (instanceStateUpdates && _.isArray(instanceStateUpdates && instanceStateUpdates.length > 0)) {
            beforeTime = _.first(instanceStateUpdates).date - activity.startedDate;
            afterTime = activity.lastUpdate - _.first(instanceStateUpdates).date;
          }
          if (!myLane) {
            myLane = result.lanes[0];
          }
          if (myLane) {
            myLane.cards.push({
              id: (_ref7 = activity.uuid) != null ? _ref7.value : void 0,
              desc: activity.label,
              ready: ((_ref8 = activity.state) != null ? _ref8.toUpperCase() : void 0) === "READY",
              state: activity.state,
              processInstance: instance.instanceUUID.value,
              activityDefinitionUUID: activityDefinitionUUID,
              totalTime: totalTime,
              totalCost: 0,
              beforeTime: beforeTime,
              afterTime: afterTime
            });
          }
        }
      }
      _ref9 = result.lanes;
      for (_o = 0, _len5 = _ref9.length; _o < _len5; _o++) {
        lane = _ref9[_o];
        _ref10 = lane.cards;
        for (_p = 0, _len6 = _ref10.length; _p < _len6; _p++) {
          card = _ref10[_p];
          lane.totalTime = lane.totalTime + card.totalTime;
          lane.totalCost = lane.totalCost + card.totalCost;
          lane.beforeTime = lane.beforeTime + card.beforeTime;
          lane.afterTime = lane.afterTime + card.totalTime;
        }
      }
    }
    return result;
  };

}).call(this);
