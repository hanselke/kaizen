// Generated by CoffeeScript 1.4.0
(function() {
  var convertNodeCollection, convertNodeCollectionLower, getCleanIterationDescriptors, getIterationDescriptors, moment, _;

  _ = require('underscore-ext');

  moment = require('moment');

  convertNodeCollection = function(x) {
    x = x["string"];
    if (!x) {
      return [];
    }
    if (_.isArray(x)) {
      return _.map(x, function(y) {
        return y['#'];
      });
    } else {
      return [x];
    }
  };

  convertNodeCollectionLower = function(x) {
    return _.map(convertNodeCollection(x), function(y) {
      return y.toLowerCase();
    });
  };

  getCleanIterationDescriptors = function(processDefinition) {
    var descriptors, result, _ref;
    descriptors = processDefinition != null ? (_ref = processDefinition.iterationDescriptors) != null ? _ref["org.ow2.bonita.facade.def.element.impl.IterationDescriptor"] : void 0 : void 0;
    if (!(descriptors && descriptors.length > 0)) {
      return [];
    }
    result = _.map(descriptors, function(x) {
      return {
        otherNodes: convertNodeCollection(x.otherNodes),
        entryNodes: convertNodeCollection(x.entryNodes),
        exitNodes: convertNodeCollection(x.exitNodes),
        otherNodesLower: convertNodeCollectionLower(x.otherNodes),
        entryNodesLower: convertNodeCollectionLower(x.entryNodes),
        exitNodesLower: convertNodeCollectionLower(x.exitNodes)
      };
    });
    return result;
  };

  getIterationDescriptors = function(processDefinition) {
    var currentEntryNode, currentExitNode, descriptors, i, n, result, _i, _len, _ref;
    descriptors = getCleanIterationDescriptors(processDefinition);
    if (!(descriptors && descriptors.length > 0)) {
      return [];
    }
    result = [];
    currentEntryNode = null;
    currentExitNode = null;
    _ref = [0, descriptors.length - 1];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      if (currentEntryNode === null) {
        /*  
          step 1: look for the IterationDescriptor group with an empty <otherNodes>, marked by <otherNodes/>
        
            this represents the first step of the process
            Look for the <entryNodes> (there should only be 1), and that name is the name of the first activity
            Look for <exitNodes> (should be only 1), and that is the name of the 2nd activity
        
        
            You need to store the current process path,
              step1:<EntryNode>
              step2:<ExitNode>
        */

        n = _.find(descriptors, function(x) {
          return x.otherNodes.length === 0;
        });
        currentEntryNode = _.first(n.entryNodes);
        currentExitNode = _.first(n.exitNodes);
        if (n) {
          result.push(n);
        }
      } else {
        /*
        
            step 2: look within the <otherNodes> group of the other IterationDescriptor , and make sure that it ONLY contains
        
                1) Step2 from the current process path
                2) Assign_ $exitNode
        
              add to the current process path,
                step3:Assign_$exitNode
                step4:exitNode
        
            step 3: look within the <otherNodes> group of the other IterationDescriptor , and make sure that it ONLY contains
                1) Step2-step4 from the current process path
                2) Assign_$exitNode
        
              add to the current process path,
        
                step5:Assign_$exitNode
                step6:$exitNode
        
        
                with the current process path, see where the human tasks from subgoal1: fits in, then you know how to display them on the board.
        */

        n = _.find(descriptors, function(x) {
          if (!_.contains(x.otherNodesLower, currentExitNode.toLowerCase())) {
            return false;
          }
          if (!_.contains(x.otherNodesLower, "assign_" + _.first(x.exitNodesLower))) {
            return false;
          }
          return x.otherNodes.length === 2;
        });
        if (n) {
          currentEntryNode = _.first(n.entryNodes);
          currentExitNode = _.first(n.exitNodes);
          result.push(n);
        }
      }
    }
    console.log("----##");
    console.log(JSON.stringify(result));
    console.log("----##");
    return result;
  };

  /*
  Transforms raw data to the one that is sent to the client.
  */


  module.exports = function(processDefinition, processInstances) {
    var activity, activityDefinition, activityDefinitionUUID, adMap, afterTime, beforeTime, card, instance, instanceStateUpdates, lane, lastUpdate, myLane, newLane, result, startedDate, totalTime, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    result = {
      lanes: []
    };
    adMap = {};
    _ref1 = (_ref = processDefinition.activities) != null ? _ref.ActivityDefinition : void 0;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      activityDefinition = _ref1[_i];
      if (activityDefinition.description && _.isString(activityDefinition.description) && activityDefinition.description.length > 0 && activityDefinition.uuid && activityDefinition.uuid.value) {
        newLane = {
          label: activityDefinition.description || "",
          name: activityDefinition.name || "",
          id: activityDefinition.uuid.value,
          totalTime: 0,
          totalCost: 0,
          beforeTime: 0,
          afterTime: 0,
          cards: []
        };
        result.lanes.push(newLane);
        adMap[activityDefinition.uuid.value] = newLane;
      }
    }
    /*
      result.lanes.push
        label : "Done"
        name : 'done'
        cards: []
    */

    _ref2 = processInstances != null ? processInstances.ProcessInstance : void 0;
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      instance = _ref2[_j];
      _ref4 = (_ref3 = instance.activities) != null ? _ref3.ActivityInstance : void 0;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        activity = _ref4[_k];
        activityDefinitionUUID = (_ref5 = activity.activityDefinitionUUID) != null ? _ref5.value : void 0;
        if (true) {
          myLane = adMap[activityDefinitionUUID];
          /*
                              startedDate= moment( activity.startedDate || 0) #1354080180430
                    lastUpdate = moment(activity.lastUpdate || 0)   #1354088710758
          */

          startedDate = activity.startedDate || 0;
          lastUpdate = activity.lastUpdate || 0;
          totalTime = lastUpdate - startedDate;
          beforeTime = 0;
          afterTime = 0;
          if (startedDate === 0 || lastUpdate === 0 || totalTime > 10000000000) {
            totalTime = 0;
            beforeTime = 0;
            afterTime = 0;
          }
          instanceStateUpdates = activity.instanceStateUpdates;
          if (_.isObject(instanceStateUpdates) && _.keys(instanceStateUpdates).length > 0) {
            instanceStateUpdates = [instanceStateUpdates.InstanceStateUpdate];
          }
          if (instanceStateUpdates && _.isArray(instanceStateUpdates && instanceStateUpdates.length > 0)) {
            beforeTime = _.first(instanceStateUpdates).date - activity.startedDate;
            afterTime = activity.lastUpdate - _.first(instanceStateUpdates).date;
          }
          if (myLane) {
            myLane.cards.push({
              id: (_ref6 = activity.uuid) != null ? _ref6.value : void 0,
              desc: activity.label,
              ready: ((_ref7 = activity.state) != null ? _ref7.toUpperCase() : void 0) === "READY",
              state: activity.state,
              processInstance: instance.instanceUUID.value,
              totalTime: totalTime,
              totalCost: 0,
              beforeTime: beforeTime,
              afterTime: afterTime
            });
          }
        }
      }
      _ref8 = result.lanes;
      for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {
        lane = _ref8[_l];
        _ref9 = lane.cards;
        for (_m = 0, _len4 = _ref9.length; _m < _len4; _m++) {
          card = _ref9[_m];
          lane.totalTime = lane.totalTime + card.totalTime;
          lane.totalCost = lane.totalCost + card.totalCost;
          lane.beforeTime = lane.beforeTime + card.beforeTime;
          lane.afterTime = lane.afterTime + card.totalTime;
        }
      }
    }
    getIterationDescriptors(processDefinition);
    return result;
  };

}).call(this);
