// Generated by CoffeeScript 1.4.0
(function() {
  var activityDefinitionTransformer, cleanDesc, isInReadyState, moment, orderFromActivityDefinition, _;

  _ = require('underscore-ext');

  moment = require('moment');

  activityDefinitionTransformer = require('./activity-definition-transformer');

  orderFromActivityDefinition = function(activityDefinition) {
    var label;
    if (!(activityDefinition.label && activityDefinition.label.length > 0 && activityDefinition.label.indexOf(" ") > 0)) {
      return 9999;
    }
    label = activityDefinition.label.substr(0, activityDefinition.label.indexOf(" "));
    return parseInt(label, 0);
  };

  isInReadyState = function(activityDefinitionUUID, activityDefinitions) {
    var activityDefinition;
    if (activityDefinitions == null) {
      activityDefinitions = [];
    }
    if (!activityDefinitionUUID) {
      return true;
    }
    activityDefinition = _.find(activityDefinitions, function(x) {
      return x.id === activityDefinitionUUID;
    });
    if (!activityDefinition) {
      return true;
    }
    return activityDefinition.isAssign || activityDefinition.isStart || activityDefinition.isEnd;
  };

  cleanDesc = function(label) {
    if (!(label && label.length > "Assign ".length && label.indexOf("Assign ") === 0)) {
      return label;
    }
    label = label.substr("Assign ".length);
    return label[0].toUpperCase() + label.substr(1);
  };

  /*
  Transforms raw data to the one that is sent to the client.
  */


  module.exports = function(processDefinition, processInstances) {
    var aaXX, activity, activityDefinition, activityDefinitionForGroup, activityDefinitionUUID, activityDefinitions, adMap, card, d, dd, executionTime, group, i, instance, instanceStateUpdates, lane, lastUpdate, myLane, pp, result, sortedActivityDefinitionsForState, startedDate, totalTime, waitingTime, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    result = {
      lanes: []
    };
    /*
      Here is what needs to happen now:
      1. We need to build the lanes
      We have 1 + n lanes, where the first one is the start lane, and the rest are, sorted by order, the isState activity definitons
    */

    activityDefinitions = _.map((_ref = processDefinition.activities) != null ? _ref.ActivityDefinition : void 0, activityDefinitionTransformer);
    adMap = {};
    result.lanes.push({
      label: "Start",
      name: "",
      order: 0,
      activityDefinitions: [],
      id: '',
      totalTime: 0,
      totalCost: 0,
      executionTime: 0,
      waitingTime: 0,
      cards: []
    });
    sortedActivityDefinitionsForState = _.sortBy(_.filter(activityDefinitions, function(x) {
      return x.isState;
    }), function(x) {
      return x.order;
    });
    for (_i = 0, _len = sortedActivityDefinitionsForState.length; _i < _len; _i++) {
      activityDefinition = sortedActivityDefinitionsForState[_i];
      result.lanes.push({
        label: activityDefinition.description || "",
        name: activityDefinition.name || "",
        order: activityDefinition.order,
        id: activityDefinition.id,
        totalTime: 0,
        totalCost: 0,
        executionTime: 0,
        waitingTime: 0,
        activityDefinitions: [activityDefinition],
        cards: []
      });
    }
    /*
      2. We need to assign activityDefinition's to the right lanes,starting wiht start and end.
    */

    _.first(result.lanes).activityDefinitions.push(_.find(activityDefinitions, function(x) {
      return x.isStart;
    }));
    _.last(result.lanes).activityDefinitions.push(_.find(activityDefinitions, function(x) {
      return x.isEnd;
    }));
    /*
      3. And now the fun part, we go from element 1 to n and find the matching assign+group,
      and put that in lane n - 1
    */

    for (i = _j = 1, _ref1 = result.lanes.length - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
      group = _.first(result.lanes[i].activityDefinitions).group;
      activityDefinitionForGroup = _.find(activityDefinitions, function(x) {
        return x.isAssign && x.group === group;
      });
      result.lanes[i - 1].activityDefinitions.push(activityDefinitionForGroup);
    }
    /*
      4. Now we assign it to the map
    */

    _ref2 = result.lanes;
    for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
      lane = _ref2[_k];
      _ref3 = lane.activityDefinitions;
      for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
        activityDefinition = _ref3[_l];
        adMap[activityDefinition.id] = lane;
      }
    }
    /*
      5. Now we work with process instances.
    */

    pp = [];
    if (_.isArray(processInstances.ProcessInstance)) {
      pp = processInstances.ProcessInstance;
    } else if (processInstances.ProcessInstance) {
      pp = [processInstances.ProcessInstance];
    }
    for (_m = 0, _len3 = pp.length; _m < _len3; _m++) {
      instance = pp[_m];
      activity = null;
      aaXX = (_ref4 = instance.activities) != null ? _ref4.ActivityInstance : void 0;
      if (aaXX && _.isArray(aaXX)) {
        dd = (function() {
          var _len4, _n, _results;
          _results = [];
          for (_n = 0, _len4 = aaXX.length; _n < _len4; _n++) {
            d = aaXX[_n];
            if (d.state !== "FINISHED") {
              _results.push(d);
            }
          }
          return _results;
        })();
        activity = _.last(dd);
      } else if (aaXX) {
        activity = aaXX;
      }
      if (activity) {
        activityDefinitionUUID = (_ref5 = activity.activityDefinitionUUID) != null ? _ref5.value : void 0;
        if (true) {
          myLane = adMap[activityDefinitionUUID];
          /*
                              startedDate= moment( activity.startedDate || 0) #1354080180430
                    lastUpdate = moment(activity.lastUpdate || 0)   #1354088710758
          */

          startedDate = activity.startedDate || 0;
          lastUpdate = activity.lastUpdate || 0;
          totalTime = lastUpdate - startedDate;
          executionTime = 0;
          waitingTime = 0;
          if (startedDate === 0 || lastUpdate === 0 || totalTime > 10000000000) {
            totalTime = 0;
            executionTime = 0;
            waitingTime = 0;
          }
          instanceStateUpdates = activity.instanceStateUpdates;
          if (_.isObject(instanceStateUpdates) && _.keys(instanceStateUpdates).length > 0) {
            instanceStateUpdates = [instanceStateUpdates.InstanceStateUpdate];
          }
          if (instanceStateUpdates && _.isArray(instanceStateUpdates && instanceStateUpdates.length > 0)) {
            executionTime = _.first(instanceStateUpdates).date - activity.startedDate;
            waitingTime = activity.lastUpdate - _.first(instanceStateUpdates).date;
          }
          if (!myLane) {
            myLane = result.lanes[0];
          }
          if (myLane) {
            myLane.cards.push({
              id: (_ref6 = activity.uuid) != null ? _ref6.value : void 0,
              desc: cleanDesc(activity.label),
              ready: isInReadyState((_ref7 = activity.uuid) != null ? _ref7.value : void 0, activityDefinitions),
              state: activity.state,
              processInstance: instance.instanceUUID.value,
              activityDefinitionUUID: activityDefinitionUUID,
              totalTime: totalTime,
              totalCost: 0,
              executionTime: executionTime,
              waitingTime: waitingTime
            });
          }
        }
      }
      _ref8 = result.lanes;
      for (_n = 0, _len4 = _ref8.length; _n < _len4; _n++) {
        lane = _ref8[_n];
        _ref9 = lane.cards;
        for (_o = 0, _len5 = _ref9.length; _o < _len5; _o++) {
          card = _ref9[_o];
          lane.totalTime = lane.totalTime + card.totalTime;
          lane.totalCost = lane.totalCost + card.totalCost;
          lane.executionTime = lane.executionTime + card.executionTime;
          lane.waitingTime = lane.waitingTime + card.totalTime;
        }
      }
    }
    return result;
  };

}).call(this);
