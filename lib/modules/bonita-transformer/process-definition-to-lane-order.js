// Generated by CoffeeScript 1.4.0
(function() {
  var convertNodeCollection, convertNodeCollectionLower, getCleanIterationDescriptors, _;

  _ = require('underscore-ext');

  convertNodeCollection = function(x) {
    x = x["string"];
    if (!x) {
      return [];
    }
    if (_.isArray(x)) {
      return _.map(x, function(y) {
        return y['#'];
      });
    } else {
      return [x];
    }
  };

  convertNodeCollectionLower = function(x) {
    return _.map(convertNodeCollection(x), function(y) {
      return y.toLowerCase();
    });
  };

  getCleanIterationDescriptors = function(processDefinition) {
    var descriptors, result, _ref;
    descriptors = processDefinition != null ? (_ref = processDefinition.iterationDescriptors) != null ? _ref["org.ow2.bonita.facade.def.element.impl.IterationDescriptor"] : void 0 : void 0;
    if (!(descriptors && descriptors.length > 0)) {
      return [];
    }
    result = _.map(descriptors, function(x) {
      return {
        otherNodes: convertNodeCollection(x.otherNodes),
        entryNodes: convertNodeCollection(x.entryNodes),
        exitNodes: convertNodeCollection(x.exitNodes),
        otherNodesLower: convertNodeCollectionLower(x.otherNodes),
        entryNodesLower: convertNodeCollectionLower(x.entryNodes),
        exitNodesLower: convertNodeCollectionLower(x.exitNodes)
      };
    });
    return result;
  };

  module.exports = function(processDefinition) {
    var currentEntryNode, currentExitNode, descriptors, i, n, result, _i, _len, _ref;
    descriptors = getCleanIterationDescriptors(processDefinition);
    if (!(descriptors && descriptors.length > 0)) {
      return [];
    }
    result = [];
    currentEntryNode = null;
    currentExitNode = null;
    _ref = [0, descriptors.length - 1];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      console.log("DESCRIPTORS====");
      console.log(JSON.stringify(descriptors));
      console.log("DESCRIPTORS----");
      if (currentEntryNode === null) {
        /*  
          step 1: look for the IterationDescriptor group with an empty <otherNodes>, marked by <otherNodes/>
        
            this represents the first step of the process
            Look for the <entryNodes> (there should only be 1), and that name is the name of the first activity
            Look for <exitNodes> (should be only 1), and that is the name of the 2nd activity
        
        
            You need to store the current process path,
              step1:<EntryNode>
              step2:<ExitNode>
        */

        n = _.find(descriptors, function(x) {
          return x.otherNodes.length === 0;
        });
        descriptors = _.reject(descriptors, function(x) {
          return x.otherNodes.length === 0;
        });
        currentEntryNode = _.first(n.entryNodes);
        currentExitNode = _.first(n.exitNodes);
        console.log("NEW ENTRY: " + currentEntryNode);
        console.log("NEW EXIT: " + currentExitNode);
        if (n) {
          result.push(n);
        }
      } else {
        /*
        
            step 2: look within the <otherNodes> group of the other IterationDescriptor , and make sure that it ONLY contains
        
                1) Step2 from the current process path
                2) Assign_ $exitNode
        
              add to the current process path,
                step3:Assign_$exitNode
                step4:exitNode
        
            step 3: look within the <otherNodes> group of the other IterationDescriptor , and make sure that it ONLY contains
                1) Step2-step4 from the current process path
                2) Assign_$exitNode
        
              add to the current process path,
        
                step5:Assign_$exitNode
                step6:$exitNode
        
        
                with the current process path, see where the human tasks from subgoal1: fits in, then you know how to display them on the board.
        */

        n = _.find(descriptors, function(x) {
          if (!_.contains(x.otherNodesLower, currentExitNode.toLowerCase())) {
            return false;
          }
          if (!_.contains(x.otherNodesLower, "assign_" + _.first(x.exitNodesLower))) {
            return false;
          }
          return true;
        });
        if (n) {
          currentEntryNode = _.first(n.entryNodes);
          currentExitNode = _.first(n.exitNodes);
          console.log("NEW ENTRY: " + currentEntryNode);
          console.log("NEW EXIT: " + currentExitNode);
          result.push(n);
        }
      }
    }
    console.log("XXXX====");
    console.log(JSON.stringify(result));
    console.log("XXXX----");
    return result;
  };

}).call(this);
