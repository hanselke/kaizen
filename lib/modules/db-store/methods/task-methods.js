// Generated by CoffeeScript 1.4.0
(function() {
  var ObjectId, PageResult, PageResultInfinite, TaskMethods, errors, mongoose, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore-ext');

  PageResult = require('simple-paginator').PageResult;

  PageResultInfinite = require('simple-paginator').PageResultInfinite;

  errors = require('some-errors');

  mongoose = require("mongoose");

  ObjectId = mongoose.Types.ObjectId;

  module.exports = TaskMethods = (function() {
    var CREATE_FIELDS, UPDATE_FIELDS;

    CREATE_FIELDS = ['_id', 'processDefinitionId', 'checkedOutByUserId', 'createdBy', 'state', 'checkedOutDate', 'totalWaitingTime', 'totalActiveTime', 'activeActivityName', 'stateCompleted', 'nextState', 'name', 'taskEnded', 'checkedInDate', 'message', 'timePerState', 'previousState', 'onHold', 'taskRejected'];

    UPDATE_FIELDS = ['processDefinitionId', 'checkedOutByUserId', 'state', 'checkedOutDate', 'totalWaitingTime', 'totalActiveTime', 'activeActivityName', 'stateCompleted', 'nextState', 'name', 'taskEnded', 'checkedInDate', 'message', 'timePerState', 'previousState', 'onHold', 'taskRejected'];

    function TaskMethods(models) {
      this.models = models;
      this.patch = __bind(this.patch, this);

      this["delete"] = __bind(this["delete"], this);

      this.get = __bind(this.get, this);

      this.getActiveTask = __bind(this.getActiveTask, this);

      this.create = __bind(this.create, this);

      this.allforDay = __bind(this.allforDay, this);

      this.all = __bind(this.all, this);

      this.aggregatedTaskTimesForBoardPerState = __bind(this.aggregatedTaskTimesForBoardPerState, this);

      this.tasksEndedForBoard = __bind(this.tasksEndedForBoard, this);

      this.tasksForBoard = __bind(this.tasksForBoard, this);

      this.countTasksForProcessDefinitionId = __bind(this.countTasksForProcessDefinitionId, this);

      this.getTaskForStates = __bind(this.getTaskForStates, this);

    }

    TaskMethods.prototype.getTaskForStates = function(states, options, cb) {
      var query,
        _this = this;
      if (states == null) {
        states = [];
      }
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      query = this.models.Task.findOne({
        stateCompleted: true,
        checkedOutByUserId: null,
        taskEnded: false
      });
      query.sort('updatedAt');
      query.where('nextState')["in"](states);
      return query.exec(function(err, item) {
        if (err) {
          return cb(err);
        }
        return cb(null, item);
      });
    };

    TaskMethods.prototype.countTasksForProcessDefinitionId = function(processDefinitionId, options, cb) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      return this.models.Task.count({
        processDefinitionId: processDefinitionId
      }, function(err, totalCount) {
        if (err) {
          return cb(err);
        }
        return cb(null, totalCount);
      });
    };

    TaskMethods.prototype.tasksForBoard = function(options, cb) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      options.offset || (options.offset = 0);
      options.count || (options.count = 200);
      return this.models.Task.count({}, function(err, totalCount) {
        var query;
        if (err) {
          return cb(err);
        }
        query = _this.models.Task.find({
          taskEnded: false
        });
        query.sort('-createdAt');
        query.setOptions({
          skip: options.offset,
          limit: options.count
        });
        return query.exec(function(err, items) {
          if (err) {
            return cb(err);
          }
          return cb(null, new PageResult(items || [], totalCount, options.offset, options.count));
        });
      });
    };

    TaskMethods.prototype.tasksEndedForBoard = function(options, cb) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      options.offset || (options.offset = 0);
      options.count || (options.count = 50);
      return this.models.Task.count({}, function(err, totalCount) {
        var query;
        if (err) {
          return cb(err);
        }
        query = _this.models.Task.find({
          taskEnded: true
        });
        query.sort('-createdAt');
        query.setOptions({
          skip: options.offset,
          limit: options.count
        });
        return query.exec(function(err, items) {
          if (err) {
            return cb(err);
          }
          return cb(null, new PageResult(items || [], totalCount, options.offset, options.count));
        });
      });
    };

    TaskMethods.prototype.aggregatedTaskTimesForBoardPerState = function(options, cb) {
      var query,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      query = this.models.Task.find();
      query.select('_id timePerState');
      return query.exec(function(err, items) {
        var key, state, states, val, x, _i, _len, _ref;
        if (err) {
          return cb(err);
        }
        states = {};
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          x = items[_i];
          _ref = x.timePerState;
          for (key in _ref) {
            val = _ref[key];
            state = states[key];
            if (!state) {
              state = {
                count: 0,
                totalActiveTime: 0,
                totalWaitingTime: 0,
                totalTime: 0
              };
              states[key] = state;
            }
            state.count += 1;
            state.totalActiveTime += val.totalActiveTime;
            state.totalWaitingTime += val.totalWaitingTime;
            state.totalTime += val.totalActiveTime + val.totalWaitingTime;
          }
        }
        for (state in states) {
          val = states[state];
          val.totalActiveTime /= val.count;
          val.totalWaitingTime /= val.count;
          val.totalTime /= val.count;
          delete val.count;
        }
        return cb(null, states);
      });
    };

    TaskMethods.prototype.all = function(options, cb) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      return this.models.Task.count({}, function(err, totalCount) {
        var query;
        if (err) {
          return cb(err);
        }
        query = _this.models.Task.find(options.query || {});
        query.sort('-createdAt');
        query.select(options.select || '_id processDefinitionId state createdAt checkedOutByUserId');
        query.setOptions({
          skip: options.offset,
          limit: options.count
        });
        return query.exec(function(err, items) {
          if (err) {
            return cb(err);
          }
          return cb(null, new PageResult(items || [], totalCount, options.offset, options.count));
        });
      });
    };

    TaskMethods.prototype.allforDay = function(dayDate, options, cb) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      return this.models.Task.count({}, function(err, totalCount) {
        var end, query, start;
        if (err) {
          return cb(err);
        }
        query = _this.models.Task.find(options.query || {});
        start = dayDate;
        end = new Date();
        end.setDate(start.getDate() + 1);
        end.setHours(0);
        end.setMinutes(0);
        end.setSeconds(0);
        end.setMilliseconds(0);
        console.log("Working against: " + start + " and " + end);
        query.where('createdAt').gte(start).lt(end);
        query.select(options.select || '_id processDefinitionId state createdAt checkedOutByUserId');
        query.setOptions({
          skip: options.offset,
          limit: options.count
        });
        mongoose.set('debug', true);
        return query.exec(function(err, items) {
          if (err) {
            return cb(err);
          }
          mongoose.set('debug', false);
          return cb(null, new PageResult(items || [], totalCount, options.offset, options.count));
        });
      });
    };

    /*
      Create a new processDefinition
    */


    TaskMethods.prototype.create = function(objs, actor, cb) {
      var data, model,
        _this = this;
      if (objs == null) {
        objs = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      data = {};
      if (!data.createdBy) {
        data.createdBy = actor;
      }
      _.extendFiltered(data, CREATE_FIELDS, objs);
      if (!(data.createdBy && data.createdBy.actorId)) {
        return cb(new errors.UnprocessableEntity("createdBy"));
      }
      model = new this.models.Task(data);
      return model.save(function(err) {
        if (err) {
          return cb(err);
        }
        return cb(null, model, true);
      });
    };

    /*
      Retrieves the currently active task, if any, for a user.
    */


    TaskMethods.prototype.getActiveTask = function(userId, options, cb) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      userId = userId.toString();
      return this.models.Task.findOne({
        checkedOutByUserId: userId,
        onHold: false
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        return cb(null, item);
      });
    };

    /*
      Retrieve a single processDefinition-item through it's id
    */


    TaskMethods.prototype.get = function(taskId, options, cb) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      return this.models.Task.findOne({
        _id: taskId
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        return cb(null, item);
      });
    };

    /*
      Retrieve a single processDefinition-item through it's id
    */


    TaskMethods.prototype["delete"] = function(taskId, options, cb) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      return this.models.Task.remove({
        _id: taskId
      }, function(err) {
        if (err) {
          return cb(err);
        }
        return cb(null);
      });
    };

    TaskMethods.prototype.patch = function(taskId, obj, options, cb) {
      var _this = this;
      if (obj == null) {
        obj = {};
      }
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      return this.models.Task.findOne({
        _id: taskId
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/tasks/" + taskId));
        }
        _.extendFiltered(item, UPDATE_FIELDS, obj);
        if (obj.timePerState) {
          item.markModified('timePerState');
        }
        return item.save(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, item);
        });
      });
    };

    return TaskMethods;

  })();

}).call(this);
