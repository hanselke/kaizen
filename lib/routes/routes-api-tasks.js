// Generated by CoffeeScript 1.4.0
(function() {
  var ObjectId, RoutesApi, async, errors, fs, mongoose, stateMachineForProcessDefinition, stateMachinePackage, statesForRoles, winston, xlsxToForm, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  async = require('async');

  winston = require('winston');

  errors = require('some-errors');

  fs = require('fs');

  xlsxToForm = require('../modules/xlsx-to-form');

  stateMachinePackage = require('openb-app-state-machine');

  stateMachineForProcessDefinition = require('./helpers/state-machine-for-process-definition');

  statesForRoles = require('./helpers/states-for-roles');

  mongoose = require("mongoose");

  ObjectId = mongoose.Types.ObjectId;

  module.exports = RoutesApi = (function() {

    function RoutesApi(settings) {
      this.onUnholdTask = __bind(this.onUnholdTask, this);

      this.onHoldTask = __bind(this.onHoldTask, this);

      this.cancelTask = __bind(this.cancelTask, this);

      this.pullTask = __bind(this.pullTask, this);

      this.getNextTask = __bind(this.getNextTask, this);

      this._addUsernameToTasks = __bind(this._addUsernameToTasks, this);

      this._getActiveProcessDefinitionId = __bind(this._getActiveProcessDefinitionId, this);

      this.completeTask = __bind(this.completeTask, this);

      this.createTask = __bind(this.createTask, this);

      this._stateMachineForAny = __bind(this._stateMachineForAny, this);

      this._stateMachineForProcessDefinitionId = __bind(this._stateMachineForProcessDefinitionId, this);

      this.getExcel = __bind(this.getExcel, this);

      this.getTaskData = __bind(this.getTaskData, this);

      this.saveTaskData = __bind(this.saveTaskData, this);

      this.setupRoutes = __bind(this.setupRoutes, this);

      this.setupLocals = __bind(this.setupLocals, this);
      _.extend(this, settings);
      if (!this.app) {
        throw new Error("app parameter is required");
      }
      if (!this.identityStore) {
        throw new Error("identityStore parameter is required");
      }
      if (!this.businessLogic) {
        throw new Error("businessLogic parameter is required");
      }
    }

    RoutesApi.prototype.setupLocals = function() {};

    RoutesApi.prototype.setupRoutes = function() {
      this.app.post('/api/tasks', this.createTask);
      this.app.get('/api/tasks/next-task', this.getNextTask);
      this.app.post('/api/tasks/:taskId/complete', this.completeTask);
      this.app.post('/api/tasks/:taskId/data', this.saveTaskData);
      this.app.get('/api/tasks/:taskId/data', this.getTaskData);
      this.app.get('/api/tasks/:taskId/excel', this.getExcel);
      this.app.post('/api/tasks/:taskId/cancel', this.cancelTask);
      this.app.post('/api/tasks/:taskId/onhold', this.onHoldTask);
      this.app.post('/api/tasks/:taskId/onunhold', this.onUnholdTask);
      return this.app.post('/api/tasks/:taskId/pull', this.pullTask);
    };

    /*
      Save the task data. Format: [ {r: 0,c:0, v: 'value' }]
    */


    RoutesApi.prototype.saveTaskData = function(req, res, next) {
      var _this = this;
      return this.dbStore.tasks.get(req.params.taskId, {}, function(err, item) {
        var dataRow, _i, _len, _ref;
        if (err) {
          return next(err);
        }
        _ref = req.body;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dataRow = _ref[_i];
          item.data["" + dataRow.r + "-" + dataRow.c] = dataRow.v;
        }
        item.markModified('data');
        return item.save(function(err) {
          if (err) {
            return next(err);
          }
          return res.json(201, {});
        });
      });
    };

    RoutesApi.prototype.getTaskData = function(req, res, next) {
      var _this = this;
      return this.dbStore.tasks.get(req.params.taskId, {}, function(err, item) {
        if (err) {
          return next(err);
        }
        return _this._stateMachineForProcessDefinitionId(item.processDefinitionId, function(err, sm) {
          var key, rc, result, v, _ref;
          if (err) {
            return next(err);
          }
          result = {};
          result.items = [];
          _ref = item.data;
          for (key in _ref) {
            v = _ref[key];
            rc = key.split('-');
            result.items.push({
              r: rc[0],
              c: rc[1],
              v: v
            });
          }
          result.processDefinitionId = item.processDefinitionId;
          result.form = sm.getFormForState(item.state);
          result.taskName = item.name;
          result.taskMessage = item.message;
          return res.json(result);
        });
      });
    };

    /*
      http://localhost:8001/api/tasks/50f9893de7d3a46cb000000b/excel
    */


    RoutesApi.prototype.getExcel = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.send(401, "Login required");
      }
      return this.dbStore.tasks.get(req.params.taskId, {}, function(err, task) {
        if (!task) {
          return res.send(404, "Task not found");
        }
        return _this.dbStore.processDefinitions.get(task.processDefinitionId, null, true, function(err, processDefinition) {
          var buffer, col, data, dimensions, row, v, _i, _j, _ref, _ref1, _ref2, _ref3;
          if (err) {
            return next(err);
          }
          if (!processDefinition) {
            return res.send(404, "Process Definition not found");
          }
          res.setHeader('Content-Type', 'text/csv');
          res.setHeader('Content-Disposition', 'fileName="' + processDefinition.sourceFilename + '.csv"');
          dimensions = processDefinition.layout.dimensions;
          data = task.data || {};
          buffer = "";
          for (row = _i = _ref = dimensions.minRow, _ref1 = dimensions.maxRow; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; row = _ref <= _ref1 ? ++_i : --_i) {
            for (col = _j = _ref2 = dimensions.minCol, _ref3 = dimensions.maxCol; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; col = _ref2 <= _ref3 ? ++_j : --_j) {
              if (col > dimensions.minCol) {
                buffer += ",";
              }
              buffer += '"';
              v = data["" + row + "-" + col];
              if (v) {
                buffer += "" + v;
              }
              buffer += '"';
            }
            buffer += "\r\n";
          }
          return res.send(buffer);
          /*
                  xlsxToForm.mergeDataIntoForm processDefinition.sourceXlsx,task.data ,(err,data) =>
          
                    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
                    res.setHeader 'Content-Disposition','fileName="' + processDefinition.sourceFilename + '"'
                    res.setHeader 'Content-Transfer-Encoding', 'binary'
                    res.setHeader 'Accept-Ranges','bytes'
          
                    res.send data
          */

        });
      });
    };

    RoutesApi.prototype._stateMachineForProcessDefinitionId = function(processDefinitionId, cb) {
      var _this = this;
      return this.dbStore.processDefinitions.get(processDefinitionId, null, true, function(err, item) {
        if (err) {
          return next(err);
        }
        return stateMachineForProcessDefinition(item, function(err, sm) {
          return cb(err, sm);
        });
      });
      /*
          @dbStore.processDefinitions.get2 processDefinitionId,{select: '_id stateMachine name'}, (err,processDefinition) =>
            return cb err if err
            return cb new Error("Process Definition #{processDefinitionId} not found.") unless processDefinition
      
            if !processDefinition.stateMachine || processDefinition.stateMachine.trim().length is 0
              return cb new Error("Missing state machine for process definition #{processDefinitionId}")
      
            smData = null
            try
              smData = JSON.parse(processDefinition.stateMachine)
            catch e
              console.log "Could not parse statemachine for #{processDefinition.name}"
              console.log processDefinition.stateMachine
              return cb new Error("Could not parse JSON State Machine for Process Defintion #{processDefinition.name}")
      
            sm = stateMachinePackage.stateMachine()
            sm.loadFromObject smData
      
            cb null,sm
      */

    };

    RoutesApi.prototype._stateMachineForAny = function(cb) {
      var _this = this;
      return this.dbStore.processDefinitions.getValidProcessDefinition({
        select: '_id stateMachine name'
      }, function(err, processDefinition) {
        var sm, smData;
        if (err) {
          return cb(err);
        }
        if (!processDefinition) {
          return cb(new Error("No valid process defintions found."));
        }
        smData = null;
        try {
          smData = JSON.parse(processDefinition.stateMachine);
        } catch (e) {
          console.log("Could not parse statemachine for " + processDefinition.name);
          console.log(processDefinition.stateMachine);
          return cb(new Error("Could not parse JSON State Machine for Process Defintion " + processDefinition.name));
        }
        sm = stateMachinePackage.stateMachine();
        sm.loadFromObject(smData);
        return cb(null, sm);
      });
    };

    /*
      Create a new task.
    */


    RoutesApi.prototype.createTask = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      if (!req.body.processDefinitionId) {
        return res.json(422, {});
      }
      return this.businessLogic.tasks.createTask(req.body.processDefinitionId, req.user._id, function(err, item) {
        if (err) {
          return next(err);
        }
        return res.json(item);
      });
    };

    RoutesApi.prototype.completeTask = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      return this.businessLogic.tasks.completeTask(req.params.taskId, req.body.fields, req.body.message, req.body.isRejected, function(err, item) {
        if (err) {
          return next(err);
        }
        return res.json(item);
      });
      /*
      
          data = req.body.fields || {}
          message = req.body.message || ''
      
          isRejected = !!req.body.isRejected
      
          @dbStore.tasks.get req.params.taskId, {}, (err,oldTask) =>
            return next err if err
            return new Error('task not found') unless oldTask
      
            @_stateMachineForProcessDefinitionId oldTask.processDefinitionId, (err, sm) =>
              return next err if err
      
              sm.getNextStateName oldTask.state,data, (err,nextState) =>
                return next err if err
      
                # the activeTime is whats added to the time between the last checkOutDate and now.
                totalActiveTime =  0
                if oldTask.totalActiveTime
                  try
                    totalActiveTime = oldTask.totalActiveTime
                  catch e
                    #nop
                
                if oldTask.checkedOutDate
                  totalActiveTime += new Date() - oldTask.checkedOutDate
                else if oldTask.createdAt
                  totalActiveTime += new Date() - oldTask.createdAt
      
                oldTask.timePerState = {} unless  oldTask.timePerState 
                unless oldTask.timePerState[oldTask.state]
                  oldTask.timePerState[oldTask.state] = 
                    totalActiveTime : 0
                    totalWaitingTime : 0
      
                if oldTask.checkedOutDate
                  oldTask.timePerState[oldTask.state].totalActiveTime += new Date() - oldTask.checkedOutDate
                else if oldTask.createdAt
                  oldTask.timePerState[oldTask.state].totalActiveTime += new Date() - oldTask.createdAt
      
                data = 
                  activeTaskUUID : null # to be deleted
                  checkedOutByUserId: null
                  checkedOutDate: null
                  checkedInDate : new Date()
                  #state: is left alone
                  stateCompleted: true
                  nextState: nextState
                  totalActiveTime: totalActiveTime
                  message : message
                  timePerState : _.clone( oldTask.timePerState)
                  taskRejected : isRejected
      
                data.taskEnded = true if nextState is "end"
                  
      
                @dbStore.tasks.patch req.params.taskId, data, {}, (err,item) =>
                  return next err if err
                  res.json item
      */

    };

    RoutesApi.prototype._getActiveProcessDefinitionId = function(next) {
      var _this = this;
      return this.dbStore.processDefinitions.firstProcessDefinition({
        select: '_id'
      }, function(err, processDefinition) {
        if (err) {
          return next(err);
        }
        if (!processDefinition) {
          return next(new Error("Process definition not found"));
        }
        return next(null, processDefinition._id);
      });
    };

    RoutesApi.prototype._addUsernameToTasks = function(lanes, cb) {
      var card, idList, lane, unresolvedUserIds, _i, _j, _len, _len1, _ref,
        _this = this;
      if (!this.usernameMap) {
        this.usernameMap = {};
      }
      if (!this.rolesMap) {
        this.rolesMap = {};
      }
      unresolvedUserIds = {};
      for (_i = 0, _len = lanes.length; _i < _len; _i++) {
        lane = lanes[_i];
        _ref = lane.cards;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          card = _ref[_j];
          if (card.userId) {
            card.username = this.usernameMap[card.userId];
            card.roles = this.rolesMap[card.userId] || [];
            if (!this.usernameMap[card.userId]) {
              unresolvedUserIds[card.userId] = true;
            }
          }
        }
      }
      if (_.keys(unresolvedUserIds).length === 0) {
        return cb(null);
      } else {
        idList = _.map(_.keys(unresolvedUserIds), function(x) {
          return new ObjectId(x.toString());
        });
        return this.identityStore.models.User.find({}).where('_id')["in"](idList).select('_id username roles').exec(function(err, items) {
          var item, _k, _l, _len2, _len3, _len4, _m, _ref1;
          if (err) {
            return cb(err);
          }
          items || (items = []);
          for (_k = 0, _len2 = items.length; _k < _len2; _k++) {
            item = items[_k];
            _this.usernameMap[item._id.toString()] = item.username;
            _this.rolesMap[item._id.toString()] = item.roles || [];
          }
          for (_l = 0, _len3 = lanes.length; _l < _len3; _l++) {
            lane = lanes[_l];
            _ref1 = lane.cards;
            for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {
              card = _ref1[_m];
              if (card.userId) {
                card.username = _this.usernameMap[card.userId];
              }
              if (card.userId) {
                card.roles = _this.rolesMap[card.userId];
              }
            }
          }
          return cb(null);
        });
      }
    };

    /*
      Retrieves the next task, if any, for the current user.
      Logic goes like this:
      1. we check if the user still has an open task. If so, we return it
      2. if not, we find an open task for the states that are valid for the given role
    */


    RoutesApi.prototype.getNextTask = function(req, res, next) {
      var userId,
        _this = this;
      if (!req.user) {
        return res.json({}, 401);
      }
      userId = req.user.id || req.user._id;
      return this.businessLogic.tasks.getNextTaskForUser(userId, req.user.roles, function(err, task) {
        if (err) {
          return next(err);
        }
        return res.json(task);
      });
    };

    RoutesApi.prototype.pullTask = function(req, res, next) {
      var userId,
        _this = this;
      if (!req.user) {
        return res.json({}, 401);
      }
      userId = req.user.id || req.user._id;
      return this.businessLogic.tasks.pullTask(req.params.taskId, userId, function(err, task) {
        if (err) {
          return next(err);
        }
        return res.json(task);
      });
      /*
      
      
      
          @dbStore.tasks.get req.params.taskId, {}, (err,task) =>
            return next err if err
            return new Error('task not found') unless task
      
            totalWaitingTime =  0
            if task.totalWaitingTime
              try
                totalWaitingTime = task.totalWaitingTime
              catch e
                #nop
            
            if task.checkedInDate
              totalWaitingTime += new Date() - task.checkedInDate
      
      
            task.timePerState = {} unless  task.timePerState 
            unless task.timePerState[task.state]
              task.timePerState[task.state] = 
                totalActiveTime : 0
                totalWaitingTime : 0
      
            if task.checkedInDate
              task.timePerState[task.state].totalWaitingTime += new Date() - task.checkedInDate
      
      
            data =
              checkedOutByUserId: req.user.id || req.user._id
              activeTaskUUID: "" 
              activeActivityName: ""
              previousState: task.state
              state: task.nextState
              nextState : null
              stateCompleted: false
              checkedOutDate: new Date()
              checkedInDate : null
              totalWaitingTime : totalWaitingTime
              timePerState : _.clone( task.timePerState)
      
            @dbStore.tasks.patch task._id,data, actor : {actorId : req.user._id || req.user.id},  (err,item) =>
              return next err if err
              console.log "UPDATED #{JSON.stringify(item)}"
      
              # Now we need to update the data store, where processInstanceID = X
              # and set the active user to the current userid,
              # and set the active task to the current task id,
              # and we need to return our own task id (which is actually the process id)
              # we also need to register the time here.
              item.id = item._id
              res.json 
                taskId : item._id
                activeTask : item
      */

    };

    RoutesApi.prototype.cancelTask = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      return this.businessLogic.tasks.cancelTask(req.params.taskId, function(err, task) {
        if (err) {
          return next(err);
        }
        return res.json(task);
      });
      /*
          @dbStore.tasks.get req.params.taskId, {}, (err,oldTask) =>
            return next err if err
            return new Error('task not found') unless oldTask
      
            if !oldTask.previousState 
              @dbStore.tasks.delete req.params.taskId, {}, (err) =>
                return next err if err
                return res.json {}
            else
              data = 
                activeTaskUUID : null # to be deleted
                checkedOutByUserId: null
                checkedOutDate: null
                checkedInDate : new Date()
                nextState : oldTask.state
                state : oldTask.previousState
                stateCompleted: true
                taskEnded : false
      
              @dbStore.tasks.patch req.params.taskId, data, {}, (err,item) =>
                return next err if err
                res.json item
      */

    };

    RoutesApi.prototype.onHoldTask = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      return this.businessLogic.tasks.onHoldTask(req.params.taskId, function(err, task) {
        if (err) {
          return next(err);
        }
        return res.json(task);
      });
      /*
          @dbStore.tasks.get req.params.taskId, {}, (err,oldTask) =>
            return next err if err
            return new Error('task not found') unless oldTask
      
            data = 
              onHold : true 
      
            @dbStore.tasks.patch req.params.taskId, data, {}, (err,item) =>
              return next err if err
              res.json item
      */

    };

    RoutesApi.prototype.onUnholdTask = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      return this.businessLogic.tasks.onUnholdTask(req.params.taskId, function(err, task) {
        if (err) {
          return next(err);
        }
        return res.json(task);
      });
      /*      
      @dbStore.tasks.get req.params.taskId, {}, (err,oldTask) =>
        return next err if err
        return new Error('task not found') unless oldTask
      
        data = 
          onHold : false 
      
        @dbStore.tasks.patch req.params.taskId, data, {}, (err,item) =>
          return next err if err
          res.json item
      */

    };

    return RoutesApi;

  })();

}).call(this);
