// Generated by CoffeeScript 1.4.0
(function() {
  var ObjectId, RoutesApi, async, errors, fs, mongoose, stateMachineForProcessDefinition, stateMachinePackage, winston, xlsxToForm, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  async = require('async');

  winston = require('winston');

  errors = require('some-errors');

  fs = require('fs');

  xlsxToForm = require('../modules/xlsx-to-form');

  stateMachinePackage = require('../modules/state-machine');

  stateMachineForProcessDefinition = require('./helpers/state-machine-for-process-definition');

  mongoose = require("mongoose");

  ObjectId = mongoose.Types.ObjectId;

  module.exports = RoutesApi = (function() {

    function RoutesApi(settings, servicesBonita) {
      this.servicesBonita = servicesBonita;
      this.putMePassword = __bind(this.putMePassword, this);

      this._addUsernameToTasks = __bind(this._addUsernameToTasks, this);

      this._getActiveProcessDefinitionId = __bind(this._getActiveProcessDefinitionId, this);

      this._stateMachineForAny = __bind(this._stateMachineForAny, this);

      this._stateMachineForProcessDefinitionId = __bind(this._stateMachineForProcessDefinitionId, this);

      this.getAdminTasks = __bind(this.getAdminTasks, this);

      this.addRole = __bind(this.addRole, this);

      this.deleteRole = __bind(this.deleteRole, this);

      this.deleteAdminUser = __bind(this.deleteAdminUser, this);

      this.postAdminUsers = __bind(this.postAdminUsers, this);

      this.getAdminUsers = __bind(this.getAdminUsers, this);

      this.deleteAdminRole = __bind(this.deleteAdminRole, this);

      this.postAdminRoles = __bind(this.postAdminRoles, this);

      this.getAdminRoles = __bind(this.getAdminRoles, this);

      this.getSession = __bind(this.getSession, this);

      this.setupRoutes = __bind(this.setupRoutes, this);

      this.setupLocals = __bind(this.setupLocals, this);

      _.extend(this, settings);
      if (!this.app) {
        throw new Error("app parameter is required");
      }
      if (!this.bonitaTransformer) {
        throw new Error("bonitaTransformer parameter is required");
      }
      if (!this.servicesBonita) {
        throw new Error("servicesBonita parameter is required");
      }
      if (!this.servicesBonita.processName) {
        throw new Error("servicesBonita.processName parameter is required");
      }
      if (!this.identityStore) {
        throw new Error("identityStore parameter is required");
      }
    }

    RoutesApi.prototype.setupLocals = function() {};

    RoutesApi.prototype.setupRoutes = function() {
      this.app.get('/api/session', this.getSession);
      this.app.get('/api/admin/tasks', this.getAdminTasks);
      this.app.get('/api/admin/users', this.getAdminUsers);
      this.app.post('/api/admin/users', this.postAdminUsers);
      this.app["delete"]('/api/admin/users/:userId', this.deleteAdminUser);
      this.app.get('/api/admin/roles', this.getAdminRoles);
      this.app.post('/api/admin/roles', this.postAdminRoles);
      this.app["delete"]('/api/admin/roles/:roleId', this.deleteAdminRole);
      this.app.post('/api/admin/users/:userId/roles/:role', this.addRole);
      this.app["delete"]('/api/admin/users/:userId/roles/:role', this.deleteRole);
      return this.app.put('/api/me/password', this.putMePassword);
    };

    /*
      Retrieve the current session (e.g. the user that is currently logged in). 
      Returns a 404 if no session exists - e.g. no user is logged in.
    */


    RoutesApi.prototype.getSession = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json({}, 404);
      }
      return this.dbStore.tasks.getActiveTask(req.user._id, {}, function(err, item) {
        var user;
        if (err) {
          return next(err);
        }
        user = req.user.toRest(_this.baseUrl);
        user.activeTask = null;
        if (item) {
          user.activeTask = item.toRest(_this.baseUrl);
        }
        return _this.dbStore.processDefinitions.all({
          actor: null,
          offset: 0,
          count: 1000
        }, function(err, result) {
          var containsAny;
          if (err) {
            return next(err);
          }
          containsAny = function(roleArray, checkAgainstRoles) {
            var x, _i, _len;
            for (_i = 0, _len = checkAgainstRoles.length; _i < _len; _i++) {
              x = checkAgainstRoles[_i];
              if (_.contains(roleArray, x)) {
                return true;
              }
            }
            return false;
          };
          result.items = _.filter(result.items, function(x) {
            return containsAny(x.createableByRoles, req.user.roles);
          });
          user.createableTasks = _.map(result.items, function(x) {
            return {
              _id: x._id,
              name: x.name,
              description: x.description
            };
          });
          return res.json(user);
        });
      });
    };

    RoutesApi.prototype.getAdminRoles = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json({}, 401);
      }
      return this.dbStore.roles.all({}, function(err, pagedResultRoles) {
        if (err) {
          return next(err);
        }
        return res.json(pagedResultRoles);
      });
    };

    RoutesApi.prototype.postAdminRoles = function(req, res, next) {
      var _this = this;
      if (!req.body.name) {
        return next(new errors.UnprocessableEntity("name"));
      }
      return this.dbStore.roles.create(req.body, {}, function(err, user) {
        if (err) {
          return next(err);
        }
        return res.json(user);
      });
    };

    RoutesApi.prototype.deleteAdminRole = function(req, res, next) {
      var roleId,
        _this = this;
      roleId = req.params.roleId;
      return this.dbStore.roles.destroy(roleId, {}, function(err, item) {
        if (err) {
          return next(err);
        }
        return res.json({});
      });
    };

    RoutesApi.prototype.getAdminUsers = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json({}, 401);
      }
      return this.dbStore.roles.all({}, function(err, rolesAsPagesResult) {
        var roles;
        if (err) {
          return next(err);
        }
        roles = _.map(rolesAsPagesResult.items || [], function(x) {
          return x.name;
        });
        if (!_.contains(roles, 'admin')) {
          roles.push("admin");
        }
        if (err) {
          return next(err);
        }
        return _this.identityStore.users.all(0, 200, function(err, result) {
          if (err) {
            return next(err);
          }
          result.roles = _.map(roles, function(role) {
            return {
              name: role,
              label: role
            };
          });
          return res.json(result);
        });
      });
    };

    RoutesApi.prototype.postAdminUsers = function(req, res, next) {
      var _this = this;
      if (!req.body.username) {
        return next(new errors.UnprocessableEntity("username"));
      }
      if (!req.body.password) {
        return next(new errors.UnprocessableEntity("password"));
      }
      if (!req.body.roles) {
        req.body.roles = [];
      }
      return this.identityStore.users.create(req.body, function(err, user) {
        if (err) {
          return next(err);
        }
        return res.json(user);
      });
    };

    RoutesApi.prototype.deleteAdminUser = function(req, res, next) {
      var userId,
        _this = this;
      userId = req.params.userId;
      return this.identityStore.users.destroy(userId, null, function(err, item) {
        if (err) {
          return next(err);
        }
        return res.json({});
      });
    };

    RoutesApi.prototype.deleteRole = function(req, res, next) {
      var role, userId,
        _this = this;
      userId = req.params.userId;
      role = req.params.role;
      return this.identityStore.users.removeRoles(userId, [role], function(err, r, item) {
        if (err) {
          return next(err);
        }
        return res.json({});
      });
    };

    RoutesApi.prototype.addRole = function(req, res, next) {
      var role, userId,
        _this = this;
      userId = req.params.userId;
      role = req.params.role;
      return this.identityStore.users.addRoles(userId, [role], function(err, r, item) {
        if (err) {
          return next(err);
        }
        return res.json({});
      });
    };

    RoutesApi.prototype.getAdminTasks = function(req, res, next) {
      var filter,
        _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      filter = null;
      if (req.query.year && req.query.month && req.query.day) {
        try {
          filter = new Date(parseInt(req.query.year), parseInt(req.query.month - 1), parseInt(req.query.day));
        } catch (e) {

        }
      }
      console.log(filter);
      if (filter) {
        return this.dbStore.tasks.allforDay(filter, {
          query: {
            taskEnded: true
          },
          actor: null,
          offset: 0,
          count: 200,
          select: '_id processDefinitionId state createdAt checkedOutByUserId name taskEnded nextState totalActiveTime totalWaitingTime'
        }, function(err, result) {
          if (err) {
            return next(err);
          }
          return res.json(result);
        });
      } else {
        return this.dbStore.tasks.all({
          query: {
            taskEnded: true
          },
          actor: null,
          offset: 0,
          count: 200,
          select: '_id processDefinitionId state createdAt checkedOutByUserId name taskEnded nextState totalActiveTime totalWaitingTime'
        }, function(err, result) {
          if (err) {
            return next(err);
          }
          return res.json(result);
        });
      }
    };

    RoutesApi.prototype._stateMachineForProcessDefinitionId = function(processDefinitionId, cb) {
      var _this = this;
      return this.dbStore.processDefinitions.get(processDefinitionId, null, true, function(err, item) {
        if (err) {
          return next(err);
        }
        return stateMachineForProcessDefinition(item, function(err, sm) {
          return cb(err, sm);
        });
      });
      /*
          @dbStore.processDefinitions.get2 processDefinitionId,{select: '_id stateMachine name'}, (err,processDefinition) =>
            return cb err if err
            return cb new Error("Process Definition #{processDefinitionId} not found.") unless processDefinition
      
            if !processDefinition.stateMachine || processDefinition.stateMachine.trim().length is 0
              return cb new Error("Missing state machine for process definition #{processDefinitionId}")
      
            smData = null
            try
              smData = JSON.parse(processDefinition.stateMachine)
            catch e
              console.log "Could not parse statemachine for #{processDefinition.name}"
              console.log processDefinition.stateMachine
              return cb new Error("Could not parse JSON State Machine for Process Defintion #{processDefinition.name}")
      
            sm = stateMachinePackage.stateMachine()
            sm.loadFromObject smData
      
            cb null,sm
      */

    };

    RoutesApi.prototype._stateMachineForAny = function(cb) {
      var _this = this;
      return this.dbStore.processDefinitions.getValidProcessDefinition({
        select: '_id stateMachine name'
      }, function(err, processDefinition) {
        var sm, smData;
        if (err) {
          return cb(err);
        }
        if (!processDefinition) {
          return cb(new Error("No valid process defintions found."));
        }
        smData = null;
        try {
          smData = JSON.parse(processDefinition.stateMachine);
        } catch (e) {
          console.log("Could not parse statemachine for " + processDefinition.name);
          console.log(processDefinition.stateMachine);
          return cb(new Error("Could not parse JSON State Machine for Process Defintion " + processDefinition.name));
        }
        sm = stateMachinePackage.stateMachine();
        sm.loadFromObject(smData);
        return cb(null, sm);
      });
    };

    RoutesApi.prototype._getActiveProcessDefinitionId = function(next) {
      var _this = this;
      return this.dbStore.processDefinitions.firstProcessDefinition({
        select: '_id'
      }, function(err, processDefinition) {
        if (err) {
          return next(err);
        }
        if (!processDefinition) {
          return next(new Error("Process definition not found"));
        }
        return next(null, processDefinition._id);
      });
    };

    RoutesApi.prototype._addUsernameToTasks = function(lanes, cb) {
      var card, idList, lane, unresolvedUserIds, _i, _j, _len, _len1, _ref,
        _this = this;
      if (!this.usernameMap) {
        this.usernameMap = {};
      }
      if (!this.rolesMap) {
        this.rolesMap = {};
      }
      unresolvedUserIds = {};
      for (_i = 0, _len = lanes.length; _i < _len; _i++) {
        lane = lanes[_i];
        _ref = lane.cards;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          card = _ref[_j];
          if (card.userId) {
            card.username = this.usernameMap[card.userId];
            card.roles = this.rolesMap[card.userId] || [];
            if (!this.usernameMap[card.userId]) {
              unresolvedUserIds[card.userId] = true;
            }
          }
        }
      }
      if (_.keys(unresolvedUserIds).length === 0) {
        return cb(null);
      } else {
        idList = _.map(_.keys(unresolvedUserIds), function(x) {
          return new ObjectId(x.toString());
        });
        return this.identityStore.models.User.find({}).where('_id')["in"](idList).select('_id username roles').exec(function(err, items) {
          var item, _k, _l, _len2, _len3, _len4, _m, _ref1;
          if (err) {
            return cb(err);
          }
          items || (items = []);
          for (_k = 0, _len2 = items.length; _k < _len2; _k++) {
            item = items[_k];
            _this.usernameMap[item._id.toString()] = item.username;
            _this.rolesMap[item._id.toString()] = item.roles || [];
          }
          for (_l = 0, _len3 = lanes.length; _l < _len3; _l++) {
            lane = lanes[_l];
            _ref1 = lane.cards;
            for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {
              card = _ref1[_m];
              if (card.userId) {
                card.username = _this.usernameMap[card.userId];
              }
              if (card.userId) {
                card.roles = _this.rolesMap[card.userId];
              }
            }
          }
          return cb(null);
        });
      }
    };

    /*
      Receives a new password:
      {
        "password":"test"
        "retypePassword":"t4wt"
      }
    */


    RoutesApi.prototype.putMePassword = function(req, res, next) {
      var userId,
        _this = this;
      if (!req.user) {
        return res.json({}, 401);
      }
      if (req.body.password !== req.body.retypePassword) {
        return res.json(422, {
          message: "Passwords must match"
        });
      }
      userId = req.user.id || req.user._id;
      return this.identityStore.users.setPassword(userId, req.body.password, {
        actorId: userId
      }, function(err, result) {
        if (err) {
          return next(err);
        }
        return res.json(200, {});
      });
    };

    return RoutesApi;

  })();

}).call(this);
