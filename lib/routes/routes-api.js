// Generated by CoffeeScript 1.4.0
(function() {
  var ObjectId, RoutesApi, async, errors, fs, mongoose, stateMachinePackage, winston, xlsxToForm, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  async = require('async');

  winston = require('winston');

  errors = require('some-errors');

  fs = require('fs');

  xlsxToForm = require('../modules/xlsx-to-form');

  stateMachinePackage = require('../modules/state-machine');

  mongoose = require("mongoose");

  ObjectId = mongoose.Types.ObjectId;

  module.exports = RoutesApi = (function() {

    function RoutesApi(settings, servicesBonita) {
      this.servicesBonita = servicesBonita;
      this.onUnholdTask = __bind(this.onUnholdTask, this);

      this.onHoldTask = __bind(this.onHoldTask, this);

      this.cancelTask = __bind(this.cancelTask, this);

      this.putMePassword = __bind(this.putMePassword, this);

      this.getNextTask = __bind(this.getNextTask, this);

      this.getBoard = __bind(this.getBoard, this);

      this._addUsernameToTasks = __bind(this._addUsernameToTasks, this);

      this._getActiveProcessDefinitionId = __bind(this._getActiveProcessDefinitionId, this);

      this.completeTask = __bind(this.completeTask, this);

      this.createTask = __bind(this.createTask, this);

      this._stateMachineForAny = __bind(this._stateMachineForAny, this);

      this._stateMachineForProcessDefinitionId = __bind(this._stateMachineForProcessDefinitionId, this);

      this.getProcessDefinitionHtml = __bind(this.getProcessDefinitionHtml, this);

      this.getExcel = __bind(this.getExcel, this);

      this.getTaskData = __bind(this.getTaskData, this);

      this.saveTaskData = __bind(this.saveTaskData, this);

      this.getProcessDefinitionCss = __bind(this.getProcessDefinitionCss, this);

      this.getAdminTasks = __bind(this.getAdminTasks, this);

      this.addRole = __bind(this.addRole, this);

      this.deleteRole = __bind(this.deleteRole, this);

      this.deleteAdminUser = __bind(this.deleteAdminUser, this);

      this.postAdminUsers = __bind(this.postAdminUsers, this);

      this.getAdminUsers = __bind(this.getAdminUsers, this);

      this.deleteAdminRole = __bind(this.deleteAdminRole, this);

      this.postAdminRoles = __bind(this.postAdminRoles, this);

      this.getAdminRoles = __bind(this.getAdminRoles, this);

      this.getSession = __bind(this.getSession, this);

      this.setupRoutes = __bind(this.setupRoutes, this);

      this.setupLocals = __bind(this.setupLocals, this);

      _.extend(this, settings);
      if (!this.app) {
        throw new Error("app parameter is required");
      }
      if (!this.bonitaTransformer) {
        throw new Error("bonitaTransformer parameter is required");
      }
      if (!this.servicesBonita) {
        throw new Error("servicesBonita parameter is required");
      }
      if (!this.servicesBonita.processName) {
        throw new Error("servicesBonita.processName parameter is required");
      }
      if (!this.identityStore) {
        throw new Error("identityStore parameter is required");
      }
    }

    RoutesApi.prototype.setupLocals = function() {};

    RoutesApi.prototype.setupRoutes = function() {
      this.app.get('/api/session', this.getSession);
      this.app.get('/api/board', this.getBoard);
      this.app.get('/api/tasks/next-task', this.getNextTask);
      this.app.post('/api/tasks', this.createTask);
      this.app.post('/api/tasks/:taskId/complete', this.completeTask);
      this.app.post('/api/tasks/:taskId/data', this.saveTaskData);
      this.app.get('/api/tasks/:taskId/data', this.getTaskData);
      this.app.get('/api/tasks/:taskId/excel', this.getExcel);
      this.app.post('/api/tasks/:taskId/cancel', this.cancelTask);
      this.app.post('/api/tasks/:taskId/onhold', this.onHoldTask);
      this.app.post('/api/tasks/:taskId/onunhold', this.onUnholdTask);
      this.app.get('/api/admin/tasks', this.getAdminTasks);
      this.app.get('/api/admin/users', this.getAdminUsers);
      this.app.post('/api/admin/users', this.postAdminUsers);
      this.app["delete"]('/api/admin/users/:userId', this.deleteAdminUser);
      this.app.get('/api/admin/roles', this.getAdminRoles);
      this.app.post('/api/admin/roles', this.postAdminRoles);
      this.app["delete"]('/api/admin/roles/:roleId', this.deleteAdminRole);
      this.app.post('/api/admin/users/:userId/roles/:role', this.addRole);
      this.app["delete"]('/api/admin/users/:userId/roles/:role', this.deleteRole);
      this.app.get('/api/process-definitions/:processDefinitionId/form-css', this.getProcessDefinitionCss);
      this.app.get('/api/process-definitions/:processDefinitionId/:taskId/form-html', this.getProcessDefinitionHtml);
      return this.app.put('/api/me/password', this.putMePassword);
    };

    /*
      Retrieve the current session (e.g. the user that is currently logged in). 
      Returns a 404 if no session exists - e.g. no user is logged in.
    */


    RoutesApi.prototype.getSession = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json({}, 404);
      }
      return this.dbStore.tasks.getActiveTask(req.user._id, {}, function(err, item) {
        var user;
        if (err) {
          return next(err);
        }
        user = req.user.toRest(_this.baseUrl);
        user.activeTask = null;
        if (item) {
          user.activeTask = item.toRest(_this.baseUrl);
        }
        return _this.dbStore.processDefinitions.all({
          actor: null,
          offset: 0,
          count: 1000
        }, function(err, result) {
          var containsAny;
          if (err) {
            return next(err);
          }
          containsAny = function(roleArray, checkAgainstRoles) {
            var x, _i, _len;
            for (_i = 0, _len = checkAgainstRoles.length; _i < _len; _i++) {
              x = checkAgainstRoles[_i];
              if (_.contains(roleArray, x)) {
                return true;
              }
            }
            return false;
          };
          result.items = _.filter(result.items, function(x) {
            return containsAny(x.createableByRoles, req.user.roles);
          });
          user.createableTasks = _.map(result.items, function(x) {
            return {
              _id: x._id,
              name: x.name,
              description: x.description
            };
          });
          return res.json(user);
        });
      });
    };

    RoutesApi.prototype.getAdminRoles = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json({}, 401);
      }
      return this.dbStore.roles.all({}, function(err, pagedResultRoles) {
        if (err) {
          return next(err);
        }
        return res.json(pagedResultRoles);
      });
    };

    RoutesApi.prototype.postAdminRoles = function(req, res, next) {
      var _this = this;
      if (!req.body.name) {
        return next(new errors.UnprocessableEntity("name"));
      }
      return this.dbStore.roles.create(req.body, {}, function(err, user) {
        if (err) {
          return next(err);
        }
        return res.json(user);
      });
    };

    RoutesApi.prototype.deleteAdminRole = function(req, res, next) {
      var roleId,
        _this = this;
      roleId = req.params.roleId;
      return this.dbStore.roles.destroy(roleId, {}, function(err, item) {
        if (err) {
          return next(err);
        }
        return res.json({});
      });
    };

    RoutesApi.prototype.getAdminUsers = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json({}, 401);
      }
      return this.dbStore.roles.all({}, function(err, rolesAsPagesResult) {
        var roles;
        if (err) {
          return next(err);
        }
        roles = _.map(rolesAsPagesResult.items || [], function(x) {
          return x.name;
        });
        if (!_.contains(roles, 'admin')) {
          roles.push("admin");
        }
        if (err) {
          return next(err);
        }
        return _this.identityStore.users.all(0, 200, function(err, result) {
          if (err) {
            return next(err);
          }
          result.roles = _.map(roles, function(role) {
            return {
              name: role,
              label: role
            };
          });
          return res.json(result);
        });
      });
    };

    RoutesApi.prototype.postAdminUsers = function(req, res, next) {
      var _this = this;
      if (!req.body.username) {
        return next(new errors.UnprocessableEntity("username"));
      }
      if (!req.body.password) {
        return next(new errors.UnprocessableEntity("password"));
      }
      if (!req.body.roles) {
        req.body.roles = [];
      }
      return this.identityStore.users.create(req.body, function(err, user) {
        if (err) {
          return next(err);
        }
        return res.json(user);
      });
    };

    RoutesApi.prototype.deleteAdminUser = function(req, res, next) {
      var userId,
        _this = this;
      userId = req.params.userId;
      return this.identityStore.users.destroy(userId, null, function(err, item) {
        if (err) {
          return next(err);
        }
        return res.json({});
      });
    };

    RoutesApi.prototype.deleteRole = function(req, res, next) {
      var role, userId,
        _this = this;
      userId = req.params.userId;
      role = req.params.role;
      return this.identityStore.users.removeRoles(userId, [role], function(err, r, item) {
        if (err) {
          return next(err);
        }
        return res.json({});
      });
    };

    RoutesApi.prototype.addRole = function(req, res, next) {
      var role, userId,
        _this = this;
      userId = req.params.userId;
      role = req.params.role;
      return this.identityStore.users.addRoles(userId, [role], function(err, r, item) {
        if (err) {
          return next(err);
        }
        return res.json({});
      });
    };

    RoutesApi.prototype.getAdminTasks = function(req, res, next) {
      var filter,
        _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      filter = null;
      if (req.query.year && req.query.month && req.query.day) {
        try {
          filter = new Date(parseInt(req.query.year), parseInt(req.query.month - 1), parseInt(req.query.day));
        } catch (e) {

        }
      }
      console.log(filter);
      if (filter) {
        return this.dbStore.tasks.allforDay(filter, {
          actor: null,
          offset: 0,
          count: 200,
          select: '_id processDefinitionId state createdAt checkedOutByUserId name taskEnded nextState totalActiveTime totalWaitingTime'
        }, function(err, result) {
          if (err) {
            return next(err);
          }
          return res.json(result);
        });
      } else {
        return this.dbStore.tasks.all({
          actor: null,
          offset: 0,
          count: 200,
          select: '_id processDefinitionId state createdAt checkedOutByUserId name taskEnded nextState totalActiveTime totalWaitingTime'
        }, function(err, result) {
          if (err) {
            return next(err);
          }
          return res.json(result);
        });
      }
    };

    /*
      http://localhost:8001/api/process-definitions/5101f5620cb4645c7800000b/form-css
    */


    RoutesApi.prototype.getProcessDefinitionCss = function(req, res, next) {
      var processDefinitionId,
        _this = this;
      processDefinitionId = req.params.processDefinitionId;
      return this.dbStore.processDefinitions.get(processDefinitionId, null, true, function(err, item) {
        if (err) {
          return next(err);
        }
        if (!(item && xlsxToForm.isValidLayout(item.layout))) {
          res.send("p.warning-box {margin-top:50px;background-color:red;color:white;}");
          return;
        }
        return xlsxToForm.createCssFromLayoutForm(item.layout, function(err, css) {
          if (err) {
            return done(err);
          }
          res.setHeader('Content-Type', 'text/css');
          return res.send(css);
        });
      });
    };

    /*
      Save the task data. Format: [ {r: 0,c:0, v: 'value' }]
    */


    RoutesApi.prototype.saveTaskData = function(req, res, next) {
      var _this = this;
      return this.dbStore.tasks.get(req.params.taskId, {}, function(err, item) {
        var dataRow, _i, _len, _ref;
        if (err) {
          return next(err);
        }
        _ref = req.body;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dataRow = _ref[_i];
          item.data["" + dataRow.r + "-" + dataRow.c] = dataRow.v;
        }
        item.markModified('data');
        return item.save(function(err) {
          if (err) {
            return next(err);
          }
          return res.json(201, {});
        });
      });
    };

    RoutesApi.prototype.getTaskData = function(req, res, next) {
      var _this = this;
      return this.dbStore.tasks.get(req.params.taskId, {}, function(err, item) {
        if (err) {
          return next(err);
        }
        return _this._stateMachineForProcessDefinitionId(item.processDefinitionId, function(err, sm) {
          var key, rc, result, v, _ref;
          if (err) {
            return next(err);
          }
          result = {};
          result.items = [];
          _ref = item.data;
          for (key in _ref) {
            v = _ref[key];
            rc = key.split('-');
            result.items.push({
              r: rc[0],
              c: rc[1],
              v: v
            });
          }
          result.processDefinitionId = item.processDefinitionId;
          result.form = sm.getFormForState(item.state);
          result.taskName = item.name;
          result.taskMessage = item.message;
          return res.json(result);
        });
      });
    };

    /*
      http://localhost:8001/api/tasks/50f9893de7d3a46cb000000b/excel
    */


    RoutesApi.prototype.getExcel = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.send(401, "Login required");
      }
      return this.dbStore.tasks.get(req.params.taskId, {}, function(err, task) {
        if (!task) {
          return res.send(404, "Task not found");
        }
        return _this.dbStore.processDefinitions.get(task.processDefinitionId, null, true, function(err, processDefinition) {
          var buffer, col, data, dimensions, row, v, _i, _j, _ref, _ref1, _ref2, _ref3;
          if (err) {
            return next(err);
          }
          if (!processDefinition) {
            return res.send(404, "Process Definition not found");
          }
          res.setHeader('Content-Type', 'text/csv');
          res.setHeader('Content-Disposition', 'fileName="' + processDefinition.sourceFilename + '.csv"');
          dimensions = processDefinition.layout.dimensions;
          data = task.data || {};
          buffer = "";
          for (row = _i = _ref = dimensions.minRow, _ref1 = dimensions.maxRow; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; row = _ref <= _ref1 ? ++_i : --_i) {
            for (col = _j = _ref2 = dimensions.minCol, _ref3 = dimensions.maxCol; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; col = _ref2 <= _ref3 ? ++_j : --_j) {
              if (col > dimensions.minCol) {
                buffer += ",";
              }
              buffer += '"';
              v = data["" + row + "-" + col];
              if (v) {
                buffer += "" + v;
              }
              buffer += '"';
            }
            buffer += "\r\n";
          }
          return res.send(buffer);
          /*
                  xlsxToForm.mergeDataIntoForm processDefinition.sourceXlsx,task.data ,(err,data) =>
          
                    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
                    res.setHeader 'Content-Disposition','fileName="' + processDefinition.sourceFilename + '"'
                    res.setHeader 'Content-Transfer-Encoding', 'binary'
                    res.setHeader 'Accept-Ranges','bytes'
          
                    res.send data
          */

        });
      });
    };

    /*
      http://localhost:8001/api/process-definitions/50d22f260b75ca1d9000000c/taskIdhere/form-html
    */


    RoutesApi.prototype.getProcessDefinitionHtml = function(req, res, next) {
      var editAllStates, processDefinitionId, taskId,
        _this = this;
      editAllStates = req.query.editAllStates;
      processDefinitionId = req.params.processDefinitionId;
      taskId = req.params.taskId;
      return this.dbStore.processDefinitions.get(processDefinitionId, null, true, function(err, item) {
        if (err) {
          return next(err);
        }
        if (!(item && xlsxToForm.isValidLayout(item.layout))) {
          res.send("<p class=\"warning\">Could not read Layout Definition for process " + item.name + "</p>");
          return;
        }
        return _this._stateMachineForProcessDefinitionId(processDefinitionId, function(err, sm) {
          if (err) {
            return next(err);
          }
          return _this.dbStore.tasks.get(taskId, {}, function(err, task) {
            var currentTaskState, options;
            if (err) {
              return next(err);
            }
            currentTaskState = sm.getExcelFieldFromState(task.state) || 'undefined';
            console.log("CURRENT TASK STATE: " + currentTaskState);
            options = {
              editAllStates: editAllStates,
              isActiveInputCell: function(cell) {
                if (!(cell.text && cell.text.length > 0)) {
                  return false;
                }
                if (!sm.existsAsExcelField(cell.text)) {
                  return false;
                }
                return true;
              },
              isActiveInputCellCurrent: function(cell) {
                if (!(cell.text && cell.text.length > 0)) {
                  return false;
                }
                if (cell.text !== currentTaskState) {
                  return false;
                }
                return true;
              }
            };
            return xlsxToForm.createHtmlFromLayoutForm(item.layout, options, function(err, html) {
              if (err) {
                return done(err);
              }
              html = "" + html;
              return res.send(html);
            });
          });
        });
      });
    };

    RoutesApi.prototype._stateMachineForProcessDefinitionId = function(processDefinitionId, cb) {
      return this._stateMachineForAny(cb);
      /*
          @dbStore.processDefinitions.get2 processDefinitionId,{select: '_id stateMachine name'}, (err,processDefinition) =>
            return cb err if err
            return cb new Error("Process Definition #{processDefinitionId} not found.") unless processDefinition
      
            if !processDefinition.stateMachine || processDefinition.stateMachine.trim().length is 0
              return cb new Error("Missing state machine for process definition #{processDefinitionId}")
      
            smData = null
            try
              smData = JSON.parse(processDefinition.stateMachine)
            catch e
              console.log "Could not parse statemachine for #{processDefinition.name}"
              console.log processDefinition.stateMachine
              return cb new Error("Could not parse JSON State Machine for Process Defintion #{processDefinition.name}")
      
            sm = stateMachinePackage.stateMachine()
            sm.loadFromObject smData
      
            cb null,sm
      */

    };

    RoutesApi.prototype._stateMachineForAny = function(cb) {
      var _this = this;
      return this.dbStore.processDefinitions.getValidProcessDefinition({
        select: '_id stateMachine name'
      }, function(err, processDefinition) {
        var sm, smData;
        if (err) {
          return cb(err);
        }
        if (!processDefinition) {
          return cb(new Error("No valid process defintions found."));
        }
        smData = null;
        try {
          smData = JSON.parse(processDefinition.stateMachine);
        } catch (e) {
          console.log("Could not parse statemachine for " + processDefinition.name);
          console.log(processDefinition.stateMachine);
          return cb(new Error("Could not parse JSON State Machine for Process Defintion " + processDefinition.name));
        }
        sm = stateMachinePackage.stateMachine();
        sm.loadFromObject(smData);
        return cb(null, sm);
      });
    };

    /*
      Create a new task.
    */


    RoutesApi.prototype.createTask = function(req, res, next) {
      var processDefinitionId,
        _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      if (!req.body.processDefinitionId) {
        return res.json(422, {});
      }
      processDefinitionId = req.body.processDefinitionId;
      return this.dbStore.processDefinitions.get2(req.body.processDefinitionId, {
        select: '_id taskNamePrefix'
      }, function(err, processDefinition) {
        if (err) {
          return next(err);
        }
        if (!processDefinition) {
          return next(new Error("createTask - Process definition " + processDefinitionId + " not found"));
        }
        return _this._stateMachineForProcessDefinitionId(req.body.processDefinitionId, function(err, sm) {
          if (err) {
            return next(err);
          }
          return _this.dbStore.tasks.countTasksForProcessDefinitionId(req.body.processDefinitionId, {}, function(err, count) {
            var initialState, name, payload;
            if (err) {
              return next(err);
            }
            count = count + 1;
            name = "" + (processDefinition.taskNamePrefix || "TASK") + count;
            initialState = sm.getInitialState();
            payload = {
              processDefinitionId: req.body.processDefinitionId,
              state: initialState,
              checkedOutByUserId: req.user._id,
              name: name
            };
            return _this.dbStore.tasks.create(payload, {
              actorId: req.user._id
            }, function(err, item) {
              if (err) {
                return next(err);
              }
              item.id = item._id;
              return res.json(item);
            });
          });
        });
      });
    };

    RoutesApi.prototype.completeTask = function(req, res, next) {
      var data, message,
        _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      data = req.body.fields || {};
      message = req.body.message || '';
      return this.dbStore.tasks.get(req.params.taskId, {}, function(err, oldTask) {
        if (err) {
          return next(err);
        }
        if (!oldTask) {
          return new Error('task not found');
        }
        return _this._stateMachineForProcessDefinitionId(oldTask.processDefinitionId, function(err, sm) {
          if (err) {
            return next(err);
          }
          return sm.getNextStateName(oldTask.state, data, function(err, nextState) {
            var totalActiveTime;
            if (err) {
              return next(err);
            }
            totalActiveTime = 0;
            if (oldTask.totalActiveTime) {
              try {
                totalActiveTime = oldTask.totalActiveTime;
              } catch (e) {

              }
            }
            if (oldTask.checkedOutDate) {
              totalActiveTime += new Date() - oldTask.checkedOutDate;
            } else if (oldTask.createdAt) {
              totalActiveTime += new Date() - oldTask.createdAt;
            }
            if (!oldTask.timePerState) {
              oldTask.timePerState = {};
            }
            if (!oldTask.timePerState[oldTask.state]) {
              oldTask.timePerState[oldTask.state] = {
                totalActiveTime: 0,
                totalWaitingTime: 0
              };
            }
            if (oldTask.checkedOutDate) {
              oldTask.timePerState[oldTask.state].totalActiveTime += new Date() - oldTask.checkedOutDate;
            } else if (oldTask.createdAt) {
              oldTask.timePerState[oldTask.state].totalActiveTime += new Date() - oldTask.createdAt;
            }
            data = {
              activeTaskUUID: null,
              checkedOutByUserId: null,
              checkedOutDate: null,
              checkedInDate: new Date(),
              stateCompleted: true,
              nextState: nextState,
              totalActiveTime: totalActiveTime,
              message: message,
              timePerState: _.clone(oldTask.timePerState)
            };
            if (nextState === "end") {
              data.taskEnded = true;
            }
            return _this.dbStore.tasks.patch(req.params.taskId, data, {}, function(err, item) {
              if (err) {
                return next(err);
              }
              return res.json(item);
            });
          });
        });
      });
    };

    RoutesApi.prototype._getActiveProcessDefinitionId = function(next) {
      var _this = this;
      return this.dbStore.processDefinitions.firstProcessDefinition({
        select: '_id'
      }, function(err, processDefinition) {
        if (err) {
          return next(err);
        }
        if (!processDefinition) {
          return next(new Error("Process definition not found"));
        }
        return next(null, processDefinition._id);
      });
    };

    RoutesApi.prototype._addUsernameToTasks = function(lanes, cb) {
      var card, idList, lane, unresolvedUserIds, _i, _j, _len, _len1, _ref,
        _this = this;
      if (!this.usernameMap) {
        this.usernameMap = {};
      }
      if (!this.rolesMap) {
        this.rolesMap = {};
      }
      unresolvedUserIds = {};
      for (_i = 0, _len = lanes.length; _i < _len; _i++) {
        lane = lanes[_i];
        _ref = lane.cards;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          card = _ref[_j];
          if (card.userId) {
            card.username = this.usernameMap[card.userId];
            card.roles = this.rolesMap[card.userId] || [];
            if (!this.usernameMap[card.userId]) {
              unresolvedUserIds[card.userId] = true;
            }
          }
        }
      }
      if (_.keys(unresolvedUserIds).length === 0) {
        return cb(null);
      } else {
        idList = _.map(_.keys(unresolvedUserIds), function(x) {
          return new ObjectId(x.toString());
        });
        return this.identityStore.models.User.find({}).where('_id')["in"](idList).select('_id username roles').exec(function(err, items) {
          var item, _k, _l, _len2, _len3, _len4, _m, _ref1;
          if (err) {
            return cb(err);
          }
          items || (items = []);
          for (_k = 0, _len2 = items.length; _k < _len2; _k++) {
            item = items[_k];
            _this.usernameMap[item._id.toString()] = item.username;
            _this.rolesMap[item._id.toString()] = item.roles || [];
          }
          for (_l = 0, _len3 = lanes.length; _l < _len3; _l++) {
            lane = lanes[_l];
            _ref1 = lane.cards;
            for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {
              card = _ref1[_m];
              if (card.userId) {
                card.username = _this.usernameMap[card.userId];
              }
              if (card.userId) {
                card.roles = _this.rolesMap[card.userId];
              }
            }
          }
          return cb(null);
        });
      }
    };

    RoutesApi.prototype.getBoard = function(req, res, next) {
      var board,
        _this = this;
      if (!req.user) {
        return res.json({}, 401);
      }
      board = {
        lanes: []
      };
      return this._getActiveProcessDefinitionId(function(err, processDefinitionId) {
        if (err || !processDefinitionId) {
          return res.json(board);
        }
        return _this._stateMachineForAny(function(err, sm) {
          var i, state, _i, _len, _ref;
          if (err) {
            return next(err);
          }
          /*
                  board.lanes.push
                    label: "On Hold"
                    name: "onhold"
                    order: 0
          
                    activityDefinitions: [] # TBDeleted
                    id: '' # TBDeleted
                    totalTime : 0
                    totalActiveTime : 0
                    totalWaitingTime : 0 
                    cards: []
          */

          _ref = sm.getSwimlanes() || [];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            state = _ref[i];
            board.lanes.push({
              label: state.label,
              name: state.name,
              order: i + 1,
              activityDefinitions: [],
              id: '',
              totalTime: 0,
              totalActiveTime: 0,
              totalWaitingTime: 0,
              cards: []
            });
          }
          return _this.dbStore.tasks.tasksForBoard({}, function(err, pagedResult) {
            if (err) {
              return next(err);
            }
            return _this.dbStore.tasks.aggregatedTaskTimesForBoardPerState({}, function(err, states) {
              var lane, laneMap, task, val, _j, _k, _l, _len1, _len2, _len3, _ref1, _ref2, _ref3;
              if (err) {
                return next(err);
              }
              laneMap = {};
              _ref1 = board.lanes;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                lane = _ref1[_j];
                laneMap[lane.name] = lane;
              }
              _ref2 = pagedResult.items || [];
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                task = _ref2[_k];
                lane = laneMap[task.state];
                /*
                              if task.onHold
                                lane = laneMap["onhold"]
                */

                if (lane) {
                  lane.cards.push({
                    id: task._id,
                    desc: task.name || 'UNNAMED',
                    ready: task.stateCompleted,
                    state: lane.name,
                    totalActiveTime: task.totalActiveTime,
                    totalWaitingTime: task.totalWaitingTime,
                    totalTime: task.totalActiveTime + task.totalWaitingTime,
                    message: task.message || '',
                    isOnHold: task.onHold,
                    updatedAt: task.updatedAt,
                    userId: task.checkedOutByUserId
                  });
                }
              }
              for (state in states) {
                val = states[state];
                lane = laneMap[state];
                if (lane) {
                  _.extend(lane, val);
                }
              }
              _ref3 = board.lanes;
              for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                lane = _ref3[_l];
                lane.cards = _.sortBy(lane.cards, function(card) {
                  return "" + card.isOnHold + "-" + card.desc;
                });
              }
              return _this._addUsernameToTasks(board.lanes, function(err) {
                return res.json(board);
              });
            });
          });
        });
      });
    };

    /*
      Retrieves the next task, if any, for the current user.
      Logic goes like this:
      1. we check if the user still has an open task. If so, we return up
    */


    RoutesApi.prototype.getNextTask = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json({}, 401);
      }
      console.log("Retrieving task for " + req.user._id + " and roles " + req.user.roles);
      return this.dbStore.tasks.getActiveTask(req.user.id || req.user._id, {}, function(err, task) {
        if (err) {
          return next(err);
        }
        if (task) {
          task.id = task._id;
          res.json({
            taskId: task._id,
            activeTask: task
          });
          console.log("Task already active - returned");
          return;
        }
        return _this._getActiveProcessDefinitionId(function(err, processDefinitionId) {
          if (err) {
            return next(err);
          }
          /*
                  If this task does not have a state machine we sideline it
          */

          return _this._stateMachineForProcessDefinitionId(processDefinitionId, function(err, sm) {
            var states;
            if (err) {
              return next(err);
            }
            states = sm.getStatesForRoles(req.user.roles);
            return _this.dbStore.tasks.getTaskForProcessDefinitionIdAndStates(processDefinitionId, states, {}, function(err, task) {
              var data, totalWaitingTime;
              if (err) {
                return next(err);
              }
              if (!task) {
                return res.json({});
              }
              totalWaitingTime = 0;
              if (task.totalWaitingTime) {
                try {
                  totalWaitingTime = task.totalWaitingTime;
                } catch (e) {

                }
              }
              if (task.checkedInDate) {
                totalWaitingTime += new Date() - task.checkedInDate;
              }
              if (!task.timePerState) {
                task.timePerState = {};
              }
              if (!task.timePerState[task.state]) {
                task.timePerState[task.state] = {
                  totalActiveTime: 0,
                  totalWaitingTime: 0
                };
              }
              if (task.checkedInDate) {
                task.timePerState[task.state].totalWaitingTime += new Date() - task.checkedInDate;
              }
              data = {
                checkedOutByUserId: req.user.id || req.user._id,
                activeTaskUUID: "",
                activeActivityName: "",
                previousState: task.state,
                state: task.nextState,
                nextState: null,
                stateCompleted: false,
                checkedOutDate: new Date(),
                checkedInDate: null,
                totalWaitingTime: totalWaitingTime,
                timePerState: _.clone(task.timePerState)
              };
              return _this.dbStore.tasks.patch(task._id, data, {
                actor: {
                  actorId: req.user._id || req.user.id
                }
              }, function(err, item) {
                if (err) {
                  return next(err);
                }
                console.log("UPDATED " + (JSON.stringify(item)));
                item.id = item._id;
                return res.json({
                  taskId: item._id,
                  activeTask: item
                });
              });
            });
          });
        });
      });
    };

    /*
      Receives a new password:
      {
        "password":"test"
        "retypePassword":"t4wt"
      }
    */


    RoutesApi.prototype.putMePassword = function(req, res, next) {
      var userId,
        _this = this;
      if (!req.user) {
        return res.json({}, 401);
      }
      if (req.body.password !== req.body.retypePassword) {
        return res.json(422, {
          message: "Passwords must match"
        });
      }
      userId = req.user.id || req.user._id;
      return this.identityStore.users.setPassword(userId, req.body.password, {
        actorId: userId
      }, function(err, result) {
        if (err) {
          return next(err);
        }
        return res.json(200, {});
      });
    };

    RoutesApi.prototype.cancelTask = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      return this.dbStore.tasks.get(req.params.taskId, {}, function(err, oldTask) {
        var data;
        if (err) {
          return next(err);
        }
        if (!oldTask) {
          return new Error('task not found');
        }
        if (!oldTask.previousState) {
          return _this.dbStore.tasks["delete"](req.params.taskId, {}, function(err) {
            if (err) {
              return next(err);
            }
            return res.json({});
          });
        } else {
          data = {
            activeTaskUUID: null,
            checkedOutByUserId: null,
            checkedOutDate: null,
            checkedInDate: new Date(),
            nextState: oldTask.state,
            state: oldTask.previousState,
            stateCompleted: true,
            taskEnded: false
          };
          return _this.dbStore.tasks.patch(req.params.taskId, data, {}, function(err, item) {
            if (err) {
              return next(err);
            }
            return res.json(item);
          });
        }
      });
    };

    RoutesApi.prototype.onHoldTask = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      return this.dbStore.tasks.get(req.params.taskId, {}, function(err, oldTask) {
        var data;
        if (err) {
          return next(err);
        }
        if (!oldTask) {
          return new Error('task not found');
        }
        data = {
          onHold: true
        };
        return _this.dbStore.tasks.patch(req.params.taskId, data, {}, function(err, item) {
          if (err) {
            return next(err);
          }
          return res.json(item);
        });
      });
    };

    RoutesApi.prototype.onUnholdTask = function(req, res, next) {
      var _this = this;
      if (!req.user) {
        return res.json(401, {});
      }
      return this.dbStore.tasks.get(req.params.taskId, {}, function(err, oldTask) {
        var data;
        if (err) {
          return next(err);
        }
        if (!oldTask) {
          return new Error('task not found');
        }
        data = {
          onHold: false
        };
        return _this.dbStore.tasks.patch(req.params.taskId, data, {}, function(err, item) {
          if (err) {
            return next(err);
          }
          return res.json(item);
        });
      });
    };

    return RoutesApi;

  })();

}).call(this);
